package handler

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"

	"dns-storage/pkg/defaults"
)

type CloudflareDNS struct {
	config *defaults.DefaultConfig
}

func NewDNSProviderClient(config *defaults.DefaultConfig) *CloudflareDNS {
	return &CloudflareDNS{
		config: config,
	}
}

type RecordType string

const (
	TXTRecord RecordType = "TXT"
)

type CreateRecordRequest struct {
	Name    string     `json:"name"`
	Type    RecordType `json:"type"`
	Content string     `json:"content"`
	Comment string     `json:"comment"`
	Proxied bool       `json:"proxied"`
	TTL     int        `json:"ttl"`
}

type Record struct {
	ID                string   `json:"id"`
	Name              string   `json:"name"`
	Type              string   `json:"type"`
	Content           string   `json:"content"`
	Proxiable         bool     `json:"proxiable"`
	Proxied           bool     `json:"proxied"`
	TTL               int      `json:"ttl"`
	Settings          any      `json:"settings"`
	Meta              any      `json:"meta"`
	Comment           string   `json:"comment"`
	Tags              []string `json:"tags"`
	CreatedOn         string   `json:"created_on"`
	ModifiedOn        string   `json:"modified_on"`
	CommentModifiedOn string   `json:"comment_modified_on"`
}

type CreateRecordResponse struct {
	Result   Record `json:"result"`
	Success  bool   `json:"success"`
	Errors   []any  `json:"errors"`
	Messages []any  `json:"messages"`
}

func (d *CloudflareDNS) CreateTXTRecord(ctx context.Context, record string, value []byte) (CreateRecordResponse, error) {
	if len(value) > MaxChunkSize {
		return CreateRecordResponse{}, fmt.Errorf("txt record value is too long")
	}
	url := fmt.Sprintf("%s/zones/%s/dns_records", d.config.CloudflareBaseURL, d.config.ZoneID)
	method := "POST"
	base64Value := base64.StdEncoding.EncodeToString(value)
	createRecordReq := CreateRecordRequest{
		Name:    record,
		Type:    TXTRecord,
		Content: base64Value,
		Comment: "Generated by dns-storage",
		Proxied: false,
		TTL:     d.config.TTL,
	}
	payload, err := json.Marshal(createRecordReq)
	if err != nil {
		return CreateRecordResponse{}, err
	}

	client := &http.Client{}
	req, err := http.NewRequest(method, url, bytes.NewReader(payload))
	if err != nil {
		return CreateRecordResponse{}, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", d.config.Token))
	req.Header.Set("Content-Type", "application/json")

	res, err := client.Do(req)
	if err != nil {
		return CreateRecordResponse{}, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return CreateRecordResponse{}, err
	}
	if res.StatusCode < 200 || res.StatusCode >= 300 {
		return CreateRecordResponse{}, fmt.Errorf("create txt record failed: status=%d body=%s", res.StatusCode, string(body))
	}
	var createRecordResponse CreateRecordResponse
	err = json.Unmarshal(body, &createRecordResponse)
	if err != nil {
		return CreateRecordResponse{}, err
	}
	return createRecordResponse, nil
}

type DeleteRecordResponse struct {
	Result   Record `json:"result"`
	Success  bool   `json:"success"`
	Errors   []any  `json:"errors"`
	Messages []any  `json:"messages"`
}

func (d *CloudflareDNS) DeleteTXTRecord(ctx context.Context, id string) (DeleteRecordResponse, error) {
	url := fmt.Sprintf("%s/zones/%s/dns_records/%s", d.config.CloudflareBaseURL, d.config.ZoneID, id)
	method := "DELETE"

	client := &http.Client{}
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return DeleteRecordResponse{}, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", d.config.Token))
	req.Header.Set("Content-Type", "application/json")

	res, err := client.Do(req)
	if err != nil {
		return DeleteRecordResponse{}, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return DeleteRecordResponse{}, err
	}
	if res.StatusCode < 200 || res.StatusCode >= 300 {
		return DeleteRecordResponse{}, fmt.Errorf("create txt record failed: status=%d body=%s", res.StatusCode, string(body))
	}
	var deleteRecordResponse DeleteRecordResponse
	err = json.Unmarshal(body, &deleteRecordResponse)
	if err != nil {
		return DeleteRecordResponse{}, err
	}
	return deleteRecordResponse, nil
}

type ResultInfo struct {
	Page       int `json:"page"`
	PerPage    int `json:"per_page"`
	Count      int `json:"count"`
	TotalCount int `json:"total_count"`
	TotalPages int `json:"total_pages"`
}

type ListRecordsResponse struct {
	Records    []Record   `json:"result"`
	Success    bool       `json:"success"`
	Errors     []any      `json:"errors"`
	Messages   []any      `json:"messages"`
	ResultInfo ResultInfo `json:"result_info"`
}

func (d *CloudflareDNS) GetTXTRecords(ctx context.Context, record string) (Record, error) {
	url := fmt.Sprintf("%s/zones/%s/dns_records?name.exact=%s", d.config.CloudflareBaseURL, d.config.ZoneID, record)
	method := "GET"

	client := &http.Client{}
	req, err := http.NewRequest(method, url, nil)
	if err != nil {
		return Record{}, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", d.config.Token))

	res, err := client.Do(req)
	if err != nil {
		return Record{}, err
	}
	defer res.Body.Close()

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return Record{}, err
	}
	var listRecordsResponse ListRecordsResponse
	err = json.Unmarshal(body, &listRecordsResponse)
	if err != nil {
		return Record{}, err
	}
	if len(listRecordsResponse.Records) == 0 {
		return Record{}, fmt.Errorf("no records found for %s", record)
	}
	return listRecordsResponse.Records[0], nil
}
